# -*- coding: utf-8 -*-
"""chapter11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xiOWojlWDCiyw8Nt0-boNhmAo8tE_yFE
"""

#last chapter, chapter 11, virtual screening

#A Virtual Screening Workflow Example

#a set of
# molecules known to bind to a particular protein, as well as a set of molecules assumed
# to not bind, to train a convolutional neural network to identify new molecules with
# the potential to bind to the target

# ERK2 MAPK1 same protein, involved in signalling

#We will train the model to distinguish a set of ERK2 active compounds from a set of
#decoy compounds. The active and decoy compounds are derived from the DUD-E
#database, which is designed for testing predictive models

# Commented out IPython magic to ensure Python compatibility.
##setup tensorflow v1
# %tensorflow_version 1.x

!wget -c https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh
!chmod +x Anaconda3-2019.10-Linux-x86_64.sh
!bash ./Anaconda3-2019.10-Linux-x86_64.sh -b -f -p /usr/local
!conda install -y -c deepchem -c rdkit -c conda-forge -c omnia deepchem-gpu=2.3.0
import sys
sys.path.append('/usr/local/lib/python3.7/site-packages/')

from rdkit import Chem
from rdkit.Chem import Draw
from rdkit.Chem.Draw import IPythonConsole
import pandas as pd
from rdkit.Chem import PandasTools
from rdkit.Chem import Descriptors
from rdkit.Chem import rdmolops
import seaborn as sns

active_df = pd.read_csv("actives_final.ism",header=None,sep=" ")
active_rows,active_cols = active_df.shape
active_df.columns = ["SMILES","ID","ChEMBL_ID"]
active_df["label"] = ["Active"]*active_rows
PandasTools.AddMoleculeColumnToFrame(active_df,"SMILES","Mol")

def add_property_columns_to_df(df_in):
    df_in["mw"] = [Descriptors.MolWt(mol) for mol in df_in.Mol]
    df_in["logP"] = [Descriptors.MolLogP(mol) for mol in df_in.Mol]
    df_in["charge"] = [rdmolops.GetFormalCharge(mol) for mol in df_in.Mol]

add_property_columns_to_df(active_df)

active_df.head()

decoy_df = pd.read_csv("decoys_final.ism",header=None,sep=" ")
decoy_df.columns = ["SMILES","ID"]
decoy_rows, decoy_cols = decoy_df.shape
decoy_df["label"] = ["Decoy"]*decoy_rows
PandasTools.AddMoleculeColumnToFrame(decoy_df,"SMILES","Mol")
add_property_columns_to_df(decoy_df)

decoy_df.head()

tmp_df = active_df.append(decoy_df)

sns.violinplot(tmp_df["label"],tmp_df["mw"])

sns.violinplot(tmp_df["label"],tmp_df["logP"])

sns.violinplot(tmp_df["label"],tmp_df["charge"])

charged = decoy_df[decoy_df["charge"] != 0]

charged.shape[0]/decoy_df.shape[0]

from neutralize import NeutraliseCharges

revised_decoy_df = decoy_df[["SMILES","ID","label"]].copy()

revised_decoy_df["SMILES"] = [NeutraliseCharges(x)[0] for x in revised_decoy_df["SMILES"]]

PandasTools.AddMoleculeColumnToFrame(revised_decoy_df,"SMILES","Mol")
add_property_columns_to_df(revised_decoy_df)

new_tmp_df = active_df.append(revised_decoy_df)

sns.violinplot(new_tmp_df["label"],new_tmp_df["charge"])

charged = revised_decoy_df[revised_decoy_df["charge"] != 0]
charged.shape[0]/revised_decoy_df.shape[0]

active_df["is_active"] = [1] * active_df.shape[0]
revised_decoy_df["is_active"] = [0] * revised_decoy_df.shape[0]
combined_df = active_df.append(revised_decoy_df)[["SMILES","ID","is_active"]]
combined_df.head()

combined_df.to_csv("dude_erk1_mk01.csv")

#part1 over

#part 2 training a predictive model

import deepchem as dc
from deepchem.models import GraphConvModel
import numpy as np
import sys
import pandas as pd
import seaborn as sns
from rdkit.Chem import PandasTools

def generate_graph_conv_model():
    batch_size = 128
    model = GraphConvModel(1, batch_size=batch_size, mode='classification',model_dir="./model_dir")
    return model

dataset_file = "dude_erk2_mk01.csv"
tasks = ["is_active"]
featurizer = dc.feat.ConvMolFeaturizer()
loader = dc.data.CSVLoader(tasks=tasks, smiles_field="SMILES", featurizer=featurizer)
dataset = loader.featurize(dataset_file, shard_size=8192)

splitter = dc.splits.RandomSplitter()

metrics = [dc.metrics.Metric(dc.metrics.matthews_corrcoef, np.mean, mode="classification")]

training_score_list = []
validation_score_list = []
transformers = []
cv_folds = 10
for i in range(0,cv_folds):
    model = generate_graph_conv_model()
    train_dataset, valid_dataset, test_dataset = splitter.train_valid_test_split(dataset)
    model.fit(train_dataset)
    train_scores = model.evaluate(train_dataset, metrics, transformers)
    training_score_list.append(train_scores["mean-matthews_corrcoef"])
    validation_scores = model.evaluate(valid_dataset, metrics, transformers)
    validation_score_list.append(validation_scores["mean-matthews_corrcoef"])
print(training_score_list)
print(validation_score_list)

sns.boxplot(["training"]*cv_folds+["validation"]*cv_folds,training_score_list+validation_score_list)

pred = [x.flatten() for x in model.predict(valid_dataset)]

pred_df = pd.DataFrame(pred,columns=["neg","pos"])

pred_df["active"] = [int(x) for x in valid_dataset.y]
pred_df["SMILES"] = valid_dataset.ids

pred_df.head()

pred_df.sort_values("pos",ascending=False).head(25)

sns.boxplot(pred_df.active,pred_df.pos)

false_negative_df = pred_df.query("active == 1 & pos < 0.5").copy()

PandasTools.AddMoleculeColumnToFrame(false_negative_df,"SMILES","Mol")

false_negative_df

false_positive_df = pred_df.query("active == 0 & pos > 0.5").copy()
PandasTools.AddMoleculeColumnToFrame(false_positive_df,"SMILES","Mol")

false_positive_df

model.fit(dataset)

#part 2 over part 3 begin

#install rd_filters for the 3rd part
!pip install git+https://github.com/PatWalters/rd_filters.git

!rd_filters -h

!rd_filters filter --in zinc_100k.smi --prefix zinc

df = pd.read_csv("zinc.csv")

df.head()

from collections import Counter
count_list = list(Counter(df.FILTER).items())
count_df = pd.DataFrame(count_list,columns=["Rule","Count"])
count_df.sort_values("Count",inplace=True,ascending=False)
count_df.head()

smiles_list = df[df.FILTER == "Filter41_12_dicarbonyl > 0"].SMILES[:10]

from rdkit import Chem
from rdkit.Chem import Draw

mol_list = [Chem.MolFromSmiles(x) for x in smiles_list]
dicarbonyl = Chem.MolFromSmarts('*C(=O)C(=O)*')
match_list = [mol.GetSubstructMatch(dicarbonyl) for mol in mol_list]
Draw.MolsToGridImage(mol_list,highlightAtomLists=match_list,molsPerRow=3)

#part 3 over , starting part 4

import deepchem as dc
import pandas as pd
from rdkit.Chem import PandasTools, Draw
from rdkit import DataStructs
from rdkit.ML.Cluster import Butina
from rdkit.Chem import rdMolDescriptors as rdmd
import seaborn as sns

model = dc.models.GraphConvModel(1, batch_size=128, mode='classification',model_dir="model_dir")
model.restore()

featurizer = dc.feat.ConvMolFeaturizer()

df = pd.read_csv("zinc.smi",sep=" ",header=None)

df.columns=["SMILES","Name"]

rows,cols = df.shape
df["Val"] = [0] * rows

df.head()

infile_name = "zinc_filtered.csv"
df.to_csv(infile_name,index=False)

loader = dc.data.CSVLoader(tasks=['Val'], smiles_field="SMILES", featurizer=featurizer)

dataset = loader.featurize(infile_name, shard_size=8192)

pred = model.predict(dataset)

pred_df = pd.DataFrame([x.flatten() for x in pred],columns=["Neg","Pos"])

sns.distplot(pred_df.Pos,rug=True)

combo_df = df.join(pred_df,how="outer")

combo_df.sort_values("Pos",inplace=True,ascending=False)

PandasTools.AddMoleculeColumnToFrame(combo_df,"SMILES","Mol")

combo_df.head()

Draw.MolsToGridImage(combo_df.Mol[:10],molsPerRow=5,legends=["%.2f" % x for x in combo_df.Pos[:10]])

def butina_cluster(mol_list,cutoff=0.35):
    fp_list = [rdmd.GetMorganFingerprintAsBitVect(m, 3, nBits=2048) for m in mol_list]
    dists = []
    nfps = len(fp_list)
    for i in range(1,nfps):
        sims = DataStructs.BulkTanimotoSimilarity(fp_list[i],fp_list[:i])
        dists.extend([1-x for x in sims])
    mol_clusters = Butina.ClusterData(dists,nfps,cutoff,isDistData=True)
    cluster_id_list = [0]*nfps
    for idx,cluster in enumerate(mol_clusters,1):
        for member in cluster:
            cluster_id_list[member] = idx
    return cluster_id_list

best_100_df = combo_df.head(100).copy()

best_100_df["Cluster"] = butina_cluster(best_100_df.Mol)

best_100_df.head()

len(best_100_df.Cluster.unique())

best_cluster_rep_df = best_100_df.drop_duplicates("Cluster")

best_cluster_rep_df.shape

best_cluster_rep_df.to_csv("best_cluster_represenatives.csv")

#mols = best_cluster_rep_df.iloc[:,5]

#type(mols)

#chapter over

