# -*- coding: utf-8 -*-
"""chapter9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LuWA1AP6Q-cZFngLTsC7rT6sSAjqTtap
"""

#Generative Adversarial Networks GANs
#variational autoencoder for molecule desing

# Commented out IPython magic to ensure Python compatibility.
##setup tensorflow v1
# %tensorflow_version 1.x

## this will install anaconda and deepchem, will add path, execution will take sometime

!wget -c https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh
!chmod +x Anaconda3-2019.10-Linux-x86_64.sh
!bash ./Anaconda3-2019.10-Linux-x86_64.sh -b -f -p /usr/local
!conda install -y -c deepchem -c rdkit -c conda-forge -c omnia deepchem-gpu=2.3.0
import sys
sys.path.append('/usr/local/lib/python3.7/site-packages/')

############## check deepchem installation by 
import deepchem as dc
dc.__version__ #should match with the installed

tasks, datasets, transformers = dc.molnet.load_muv()
train_dataset, valid_dataset, test_dataset = datasets
train_smiles = train_dataset.ids

#generate grammar
tokens = set()
for s in train_smiles:
  tokens = tokens.union(set(s))
tokens = sorted(list(tokens))
max_length = max(len(s) for s in train_smiles)

print(tokens)
print (max_length)

# architcture is Aspuruguzik Autoencoder

# AspuruGuzikAutoEncoder class, which implements a particular published model. It
# uses a convolutional network for the encoder and a recurrent network for the
# decoder.

# Build the model.

from deepchem.models.optimizers import ExponentialDecay
from deepchem.models.seqtoseq import AspuruGuzikAutoEncoder
batch_size = 100
batches_per_epoch = len(train_smiles)/batch_size
learning_rate = ExponentialDecay(0.001, 0.95, batches_per_epoch)
model = AspuruGuzikAutoEncoder(tokens, max_length, model_dir='vae', 
                               batch_size=batch_size, learning_rate=learning_rate)

# Train the model.

def generate_sequences(epochs):
  for i in range(epochs):
    for s in train_smiles:
      yield (s, s)

model.fit_sequences(generate_sequences(10))

model.restore()
#disconnected runtime in between so loading the model trained till the last checkpoint

# generate some molecules, I don't know till how many iterations the model trained

# remove redundant SMILES
import numpy as np
from rdkit import Chem
n_mols = 10000
#generates new vectors
predictions = model.predict_from_embeddings(np.random.normal(size=(n_mols,196)))
molecules = []
for p in predictions:
  smiles = ''.join(p)
  if Chem.MolFromSmiles(smiles) is not None:
    molecules.append(smiles)

#generated valid molecules
print('Generated molecules:')
#print(molecules)
print('Out of ' + str(n_mols) +' inputs, only valid molecules are: ',len(molecules))

#molecules

#analysis of the molecules generated here and those given and book
# its evident that I didn't train the model for long so the molecules it generated are bad,
# those given in book are good examples
molecules_book = ['CCCCCCNNNCCOCC',
'O=C(O)C(=O)ON/C=N/CO',
'C/C=N/COCCNSCNCCNN',
'CCCNC(C(=O)O)c1cc(OC(OC)[SH](=O)=O)ccc1N',
'CC1=C2C=CCC(=CC(Br)=CC=C1)C2',
'CCN=NNNC(C)OOCOOOOOCOOO',
'N#CNCCCCCOCCOC1COCNN1CCCCCCCCCCCCCCCCCCCOOOOOSNNCCCCCSCSCCCCCCCCCOCOOOSS',
'CCCC(=O)NC1=C(N)C=COO1',
'CCCSc1cc2nc(C)cnn2c1NC',
'CONCN1N=NN=CC=C1CC1SSS1',
'CCCOc1ccccc1OSNNOCCNCSNCCN',
'C[SH]1CCCN2CCN2C=C1N',
'CC1=C(C#N)N1NCCC1=COOO1',
'CN(NCNNNN)C(=O)CCSCc1ccco1',
'CCCN1CCC1CC=CC1=CC=S1CC=O',
'C/N=C/c1ccccc1',
'Nc1cccooo1',
'CCOc1ccccc1CCCNC(C)c1nccs1',
'CNNNNNNc1nocc1CCNNC(C)C',
'COC1=C(CON)C=C2C1=C(C)c1ccccc12',
'CCOCCCCNN(C)C',
'CCCN1C(=O)CNC1C',
'CCN',
'NCCNCc1cccc2c1C=CC=CC=C2',
'CCCCCN(NNNCNCCCCCCCCCCSCCCCCCCCCCCCCCNCCNCCCCSSCSSSSSSCCCCCCCCCCCCCSCCCCCSC)\
C(O)OCCN',
'CCCS1=CC=C(C)N(CN)C2NCC2=C1',
'CCNCCCCCCOc1cccc(F)c1',
'NN1O[SH](CCCCO)C12C=C2',
'Cc1cc2cccc3c(CO)cc-3ccc-2c1']

#converts to molecules from smiles
mols = [Chem.MolFromSmiles(x) for x in molecules_book]

#small molecules are insufficient in generating enough interaction energy
# large molecules do not dissolve in water

print(sorted([x.GetNumAtoms() for x in mols]))

good_mol_list = [x for x in mols if x.GetNumAtoms() > 10 and x.GetNumAtoms() < 50]
print(len(good_mol_list))

# select on the basis of QED Quantitative estimation of drug values

from rdkit.Chem import QED,Draw,MolToSmiles

qed_list = [QED.qed(x) for x in good_mol_list]
final_mol_list = [(a,b) for a,b in zip(good_mol_list,qed_list) if b > 0.5]

#visualize
Draw.MolsToGridImage([x[0] for x in final_mol_list],molsPerRow=3,useSVG=False,subImgSize=(250, 250),legends=[f"{x[1]:.2f}" for x in final_mol_list])

#for the molecules my model generated
mols = [Chem.MolFromSmiles(x) for x in molecules]

len(mols)

print(sorted([x.GetNumAtoms() for x in mols]))

good_mol_list = [x for x in mols if x.GetNumAtoms() > 10 and x.GetNumAtoms() < 90]
print(len(good_mol_list))

#out of 992, 774 molecules are left for analysis after sorting by size

# QED check
qed_list = [QED.qed(x) for x in good_mol_list]
final_mol_list = [(a,b) for a,b in zip(good_mol_list,qed_list) if b > 0.4]

# out of 395, only 6 molecules left after QED analysis
len(final_mol_list)

#final_mol_list

#visualize the useless list of molecules
Draw.MolsToGridImage([x[0] for x in final_mol_list],molsPerRow=3,useSVG=False,subImgSize=(250, 250),legends=[f"{x[1]:.2f}" for x in final_mol_list])

#out of all these structures none looks possible structurally

mol_list = [x[0] for x in final_mol_list]

for item in mol_list:
  print(MolToSmiles(item))

#only useful molecules
bestmol1 = 'CCCC(=O)CC(CC)CC1=CC=CCCC1C'
bestmol2 = 'CCCCCC1CCCC12C(=O)NN2C'
bestmol3 = 'CCCCCCCCNC(=O)C1=C(C(=O)OCC)C=CC=CC1'
bestmol4 = 'CCCCCC1CC=C1C(=O)CNNNC(=O)CN'
bestmol5 = 'Cc1nnccc1CCCCCCCCN'
bestmol1 = [Chem.MolFromSmiles(bestmol1)]
bestmol2 = [Chem.MolFromSmiles(bestmol2)]
bestmol3 = [Chem.MolFromSmiles(bestmol3)]
bestmol4 = [Chem.MolFromSmiles(bestmol4)]
bestmol5 = [Chem.MolFromSmiles(bestmol5)]

#visualize the useless list of molecules
Draw.MolsToGridImage(bestmol1,molsPerRow=1,useSVG=False,subImgSize=(250, 250))

#visualize the useless list of molecules
Draw.MolsToGridImage(bestmol2,molsPerRow=1,useSVG=False,subImgSize=(250, 250))

Draw.MolsToGridImage(bestmol3,molsPerRow=1,useSVG=False,subImgSize=(250, 250))

Draw.MolsToGridImage(bestmol4,molsPerRow=1,useSVG=False,subImgSize=(250, 250))

Draw.MolsToGridImage(bestmol5,molsPerRow=1,useSVG=False,subImgSize=(250, 250))

#summary of the best compounds generated
# molecule1 SMILE = CCCC(=O)CC(CC)CC1=CC=CCCC1C
# molecule1 IUPAC = 6-[(7-Methyl-1,3-cycloheptadien-1-yl)methyl]-4-octanone
# molecule2 SMILE = CCCCCC1CCCC12C(=O)NN2C
# molecule2 IUPAC = 1-Methyl-5-pentyl-1,2-diaza-3-spiro[3.4]octanone
# molecule3 SMILE = CCCCCCCCNC(=O)C1=C(C(=O)OCC)C=CC=CC1
# molecule3 IUPAC = Ethyl 2-(N-octylcarbamoyl)-1,4,6-cycloheptatriene-1-carboxylate
# molecule4 SMILE = CCCCCC1CC=C1C(=O)CNNNC(=O)CN
# molecule4 IUPAC = 2-Amino-1-{3-[2-oxo-2-(4-pentyl-1-cyclobuten-1-yl)ethyl]triazanyl}-1-ethanone
# molecule5 SMILE = Cc1nnccc1CCCCCCCCN
# molecule5 IUPAC = 8-(3-Methyl-4-pyridazinyl)octylamine

#chapter completed.

