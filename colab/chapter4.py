# -*- coding: utf-8 -*-
"""chapter4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14zWTebYPBIutBgiMwQYMiJvs6AgEwbYD
"""

#chapter4
#This chapter covers the basics of performing machine learning on molecular data.

# Commented out IPython magic to ensure Python compatibility.
#setup deepchem
# %tensorflow_version 1.x

!wget -c https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh
!chmod +x Anaconda3-2019.10-Linux-x86_64.sh
!bash ./Anaconda3-2019.10-Linux-x86_64.sh -b -f -p /usr/local
!conda install -y -c deepchem -c rdkit -c conda-forge -c omnia deepchem-gpu=2.3.0
import sys
sys.path.append('/usr/local/lib/python3.7/site-packages/')
#import deepchem as dc

#checking extended connectivity fingrprint

import deepchem as dc

dc.__version__

import tensorflow as tf
tf.__version__

smiles = ['C1CCCCC1', 'O1CCOCC1'] # cyclohexane and dioxane

from rdkit import Chem

#Chem.Descriptors.descList

mols = [Chem.MolFromSmiles(smile) for smile in smiles]

#mols[0]
feat = dc.feat.CircularFingerprint(size=1024)

arr = feat.featurize(mols)

arr.shape

"""
ECFPs do have one important disadvantage: the fingerprint encodes a large amount
of information about the molecule, but some information does get lost. It is possible
for two different molecules to have identical fingerprints, and given a fingerprint, it is
impossible to uniquely determine what molecule it came from.
"""

#moleculae descriptors from physiochemical propeties
feat = dc.feat.RDKitDescriptors()

arr = feat.featurize(mols)

arr.shape

#introducing graph convolutions

"""That is what machine learning is all about, after all: instead of designing a featuriza‐
tion ourselves, we can try to learn one automatically from the data.

When the graph
represents a molecule, those numbers could be high-level chemical properties of each
atom, such as its element, charge, and hybridization state. Just as a regular convolu‐/
"""

#active

"""
Examples include graph convolutions ( GraphConvModel ), Weave models ( WeaveMo
del ), message passing neural networks ( MPNNModel ), deep tensor neural networks
( DTNNModel )

"""

#Training a Model to Predict Solubility

tasks, datasets, transformers = dc.molnet.load_delaney(featurizer='GraphConv')

train_dataset, valid_dataset, test_dataset = datasets

from deepchem.models.graph_models import GraphConvModel

model = GraphConvModel(n_tasks=1, mode='regression', dropout=0.2)

model.fit(train_dataset, nb_epoch=100)

metric = dc.metrics.Metric(dc.metrics.pearson_r2_score)

print(model.evaluate(train_dataset, [metric], transformers))

print(model.evaluate(test_dataset, [metric], transformers))

#Training r2 = .956
#Test r2 = 0859 ~ .872
#overfitting but not badly

#now predicting solubilities on different chemical compunds

# as given by the book
# smiles = ['COC(C)(C)CCCC(C)CC=CC(C)=CC(=O)OC(C)C',
# 'CCOC(=O)CC',
# 'CSc1nc(NC(C)C)nc(NC(C)C)n1',
# 'CC(C#C)N(C)C(=O)Nc1ccc(Cl)cc1',
# 'Cc1cc2ccccc2cc1C']

# the following compounds (kinase inhibitors and covid-19 drug) were not in the tutorial or the book, 
# I searched them over the internet and found their SMILES code
# I chose them because of my interest
# for Kinase they are: Afatinib and Dacomitinib
# for covid-19 they are: Remdisivir and Favipiravir
#smiles = ['CN(C)C\C=C\C(=O)Nc3cc1c(Nc(cc2Cl)ccc2F)ncnc1cc3OC4COCC4','COC1=C(C=C2C(=C1)N=CN=C2NC3=CC(=C(C=C3)F)Cl)NC(=O)/C=C/CN4CCCCC4']
smiles = ['CCC(COC(=O)[C@@H](NP(=O)(Oc1ccccc1)OC[C@H]1O[C@@]([C@@H]([C@@H]1O)O)(C#N)c1ccc2n1ncnc2N)C)CC','C1=C(N=C(C(=O)N1)C(=O)N)F']

mols = [Chem.MolFromSmiles(s) for s in smiles]

featurizer = dc.feat.ConvMolFeaturizer()

x = featurizer.featurize(mols)

x.shape

predicted_solubility = model.predict_on_batch(x)

#predicted_solubility for kinase inhibitors
#predicted_solubility = model.predict_on_batch(x)
#Afatinib = [-0.8756279]
#Dacomitinib = [-1.2739315]

#predicted_solubility for covid drugs
#predicted_solubility = model.predict_on_batch(x)
#Remdisivir = [-0.79829633]
#Favipiravir = [ 0.6713617 ]

######################## done tutorial #########

#Extension to SMART format
#extension of the SMILES language described previously that can be used to create queries

from rdkit import Chem

#visualizing
from rdkit.Chem.Draw import MolsToGridImage

#smiles_list = ["CCCCC","CCOCC","CCNCC","CCSCC"]
smiles_list = ["CCCOCCC","CCOCOC","CCCNCC","CNCOCCOC"]

mol_list = [Chem.MolFromSmiles(x) for x in smiles_list]

#Chem.Draw.MolToImage(mol_list[0])
MolsToGridImage(mols=mol_list, molsPerRow=4)

#now query 
query = Chem.MolFromSmarts("COC")
match_list = [mol.GetSubstructMatch(query) for mol in mol_list]
MolsToGridImage(mols=mol_list, molsPerRow=4,highlightAtomLists=match_list)
#this is cool

#other queries can be 
# "C*C" will match an aliphatic carbon attached to any atom 
# attached to another aliphatic carbon 

# “C[C,O,N]C” will match carbon attached to carbon, oxygen, or
# nitrogen, attached to another carbon

"""
learned about graph convolutions, which are
a newer approach to modeling molecules in deep learning, and saw a complete work‐
ing example of how to use machine learning on molecules to predict an important
physical property. These techniques will serve as the foundations upon which later
chapters will build.

"""

#chapter 4 over